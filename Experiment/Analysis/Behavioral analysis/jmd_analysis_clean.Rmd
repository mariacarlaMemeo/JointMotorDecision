---
title: "Analysis Collective decision-making"
author: "Laura Schmitz"
date: "2024-02-28"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document.
Add `echo = FALSE` parameter to the code chunk to prevent printing of the R code that generated the plot.



```{r prepSteps, echo=FALSE, warning=FALSE, error=FALSE, message=FALSE, results='hide'}
# Remove variables and plots
rm(list = ls())
graphics.off()

# Save all plots?
save_plots      = 0
# Write Excel file with all data and info file?
save_data_final = 0

# Load packages
pckgs = c("data.table","lattice","lme4", "nlme","emmeans","doBy","effsize","ez",
          "MuMIn","BayesFactor","permuco","RVAideMemoire",
          "RColorBrewer","stringr","knitr","multcomp","ggplot2","car","dplyr",
          "plyr","lmerTest","ggrepel","sjstats","reshape2","readxl","writexl",
          "cellranger")
# Load all of them and heck how many packages failed to load
sprintf("How many packages failed to load?")
sum(lapply(pckgs, require, character.only = TRUE)==FALSE)

# Set flags
local_user = 2;    # set current user (1=MC, 2=LA)
patel_mt   = FALSE # if TRUE: Does difference in MT predict inferred confidence? (Patel 2012)
pair_plots = FALSE # if TRUE: shows the confidence for each pair per decision

# Set paths (*** ADJUST TO LOCAL COMPUTER with flag local_user ***)
# ! We access (and save) everything on GitHub - DataDir=pre-processed Excel files !
if (local_user == 1) {
  DataDir = "D:/GitHub_D/joint-motor-decision/JointMotorDecision/Experiment/Data/Behavioral/preprocessed/" 
  AnaDir  = "D:/GitHub_D/joint-motor-decision/JointMotorDecision/Experiment/Analysis/Behavioral analysis/"
  PlotDir = "D:/GitHub_D/joint-motor-decision/JointMotorDecision/Experiment/Analysis/Behavioral analysis/Behavioral plots/"
} else {
  DataDir = "C:/Users/Laura/GitHub/JointMotorDecision/Experiment/Data/Behavioral/preprocessed/" #"D:/DATA/Processed/"
  AnaDir  = "C:/Users/Laura/GitHub/JointMotorDecision/Experiment/Analysis/Behavioral analysis/"
  PlotDir = "C:/Users/Laura/GitHub/JointMotorDecision/Experiment/Analysis/Behavioral analysis/Behavioral plots/"
}

# Call functions
source(paste0(AnaDir,'bind_all_excel.R'))
source(paste0(AnaDir,'summarySE.R'))
source(paste0(AnaDir,'theme_custom.R'))
source(paste0(AnaDir,'plotSE.R'))
source(paste0(AnaDir,'final_rtmt_byAgent.R'))
source(paste0(AnaDir,'compareMinMax.R'))
source(paste0(AnaDir,'jmdData_info.R'))
source(paste0(AnaDir,'check_confDistribution.R'))
```

```{r loadData, echo=FALSE, warning=FALSE, error=FALSE, message=FALSE}
# RETRIEVE DATA and CREATE DATA FRAME
# ------------------------------------------------
# Goal: Create data frame with data from all pairs.
# Steps to achieve goal:
# 1. Retrieve Excel files (1 per pair) that we created after cutting the trials (jmdData_S1xx.xlsx).
#    These Excel files are based on the preprocessed .mat files (S1xx.mat) created with the toolbox.
#    (Files located in DATA/Processed (on individual hard drives):
#    S1xx.mat (preprocessed), S1xx.mat_post and jmdData_S1xx.xlsx (final files after cutting))
# 2. Merge all Excel files into one big data frame (curdat) using the function bind_all_excel.

# merge Excel files from all pairs into one data frame named "curdat"
curdat=as.data.frame(bind_all_excel(DataDir))
curdat=curdat[,1:1061] # delete last columns (velocity peaks - different no. of columns across pairs)
```

```{r addVariables, echo=FALSE, warning=FALSE, error=FALSE, message=FALSE, results='hide'}
# Add additional vars to the curdat data frame
# --------------------------------------------

# Add a column expressing whether agents B and Y agree in their decisions [1=agreement, -1=disagreement]
curdat$agree                  = as.integer(curdat$B_decision == curdat$Y_decision)
curdat$agree[curdat$agree==0] = -1

# Add columns where decision, confidence, and accuracy are reported per 1st/2nd decision (rather than tied to agent B/Y)
# Initialize variables
decision1 = c(); conf1 = c(); acc1 = c()
decision2 = c(); conf2 = c(); acc2 = c()
# Assign values to variables
for (row in 1:dim(curdat)[1]) {
  
  f_dec = curdat[row,"AgentTakingFirstDecision"] #agent taking first decision
  if (f_dec=="B") {
    decision1[row] = curdat[row,"B_decision"]
    conf1[row]     = curdat[row,"B_conf"]
    acc1[row]      = curdat[row,"B_acc"]} else {
    decision1[row] = curdat[row,"Y_decision"]
    conf1[row]     = curdat[row,"Y_conf"]
    acc1[row]      = curdat[row,"Y_acc"]
  }
  
  s_dec = curdat[row,"AgentTakingSecondDecision"] #agent taking second decision
  if (s_dec=="B") {
    decision2[row] = curdat[row,"B_decision"]
    conf2[row]     = curdat[row,"B_conf"]
    acc2[row]      = curdat[row,"B_acc"]} else {
    decision2[row] = curdat[row,"Y_decision"]
    conf2[row]     = curdat[row,"Y_conf"]
    acc2[row]      = curdat[row,"Y_acc"]
  }
}
# Add computed values (decision, confidence, accuracy) for 1st/2nd decision
curdat$decision1   = decision1
curdat$decision2   = decision2
curdat$confidence1 = conf1
curdat$confidence2 = conf2
curdat$accuracy1   = acc1
curdat$accuracy2   = acc2

# Sanity check: just check trials in which B=Y -> then also decision1 must be equal to decision2
# (this must be TRUE)
invisible(all(as.integer(curdat$B_decision == curdat$Y_decision) == as.integer(curdat$decision1 == curdat$decision2)))

# Add columns for the confidence difference values (deltas):
# confidence2-confidence1: deltaC2C1<0 = conf2<conf1; deltaC2C1>0 = conf2>conf1
curdat$deltaC2C1 = curdat$confidence2-curdat$confidence1
# confidenceColl-confidence1: deltaCcC1<0 = Coll_conf<conf1; deltaCcC1>0 = Coll_conf>conf1
curdat$deltaCcC1 = curdat$Coll_conf-curdat$confidence1

# Add a column that indicates whether 1st and collective decision differ ("switch"),
# i.e., whether A1 switched her decision (changed her mind) [1=switch, -1=no switch]
switchR = as.integer(curdat$decision1 != curdat$Coll_decision)
# Sanity check: we already added a "switch" column in Matlab - now we check if columns are identical
# (this must be TRUE)
invisible(all(curdat$switch == switchR))
curdat$switch[curdat$switch==0] = -1 # now 1=switch, -1=no switch

# Sub-select agreement/disagreement trials
at = curdat[curdat$agree==1,]
dt = curdat[curdat$agree==-1,]
```

```{r minmaxVariables, echo=FALSE, warning=FALSE, error=FALSE, message=FALSE, results='hide'}
# Import info about max./min. agent from Excel file (created in Matlab)
minmax <- read_excel("minmaxTable.xlsx")

# Add columns on worse(min)/better(max) agent (each for confidence and accuracy)
curdat$maxAgent = NA; curdat$minAgent = NA;
curdat$maxConf = NA; curdat$maxAcc = NA; curdat$minConf = NA; curdat$minAcc = NA;
for (p in unique(curdat$Pair)) { # p = pair
  if (minmax[minmax$Pair==p,"maxAgent"] == "B") {
    curdat[curdat$Pair==p,"maxConf"]  = curdat[curdat$Pair==p,"B_conf"]
    curdat[curdat$Pair==p,"minConf"]  = curdat[curdat$Pair==p,"Y_conf"]
    curdat[curdat$Pair==p,"maxAcc"]   = curdat[curdat$Pair==p,"B_acc"]
    curdat[curdat$Pair==p,"minAcc"]   = curdat[curdat$Pair==p,"Y_acc"]
    curdat[curdat$Pair==p,"maxAgent"] = "B" # max agent in this pair
    curdat[curdat$Pair==p,"minAgent"] = "Y" # min agent in this pair
  } else {
    curdat[curdat$Pair==p,"maxConf"]  = curdat[curdat$Pair==p,"Y_conf"]
    curdat[curdat$Pair==p,"minConf"]  = curdat[curdat$Pair==p,"B_conf"]
    curdat[curdat$Pair==p,"maxAcc"]   = curdat[curdat$Pair==p,"Y_acc"]
    curdat[curdat$Pair==p,"minAcc"]   = curdat[curdat$Pair==p,"B_acc"]
    curdat[curdat$Pair==p,"maxAgent"] = "Y"
    curdat[curdat$Pair==p,"minAgent"] = "B"
  }
}

# Add column on whether min or max agent takes first decision
mima_f_dec = c()
for (row in 1:dim(curdat)[1]) {
  f_dec   = curdat[row,"AgentTakingFirstDecision"]
  max_ag  = curdat[row,"maxAgent"]
  if (f_dec=="B" & max_ag=="B") {
    mima_f_dec[row] = "max"
  } else if (f_dec=="Y" & max_ag=="Y") {
    mima_f_dec[row] = "max"
  } else if (f_dec=="B" & max_ag=="Y") {
    mima_f_dec[row] = "min"
  } else if (f_dec=="Y" & max_ag=="B") {
    mima_f_dec[row] = "min"
  }
}
curdat$mima_dec1 = mima_f_dec # who takes 1st dec. in this trial? (min or max agent)


# Check probability of switching per agent (only AgentTakingFirstDecision can switch)
# -1= no switch, 1=switch, 0=no data because agent took 2nd decision
swMax = c(); swMin = c()
for (row in 1:dim(curdat)[1]) {
  
  switch_d = curdat[row,"switch"]
  mima_d  = curdat[row,"mima_dec1"]
  
  if (switch_d==1 & mima_d=="max") {
    swMax[row] = 1
    swMin[row] = 0
  } else if (switch_d==-1 & mima_d=="max") {
    swMax[row] = -1
    swMin[row] = 0
  } else if (switch_d==1 & mima_d=="min") {
    swMax[row] = 0
    swMin[row] = 1
  } else if (switch_d==-1 & mima_d=="min") {
    swMax[row] = 0
    swMin[row] = -1
  }
}
curdat$switchMax = swMax
curdat$switchMin = swMin

# add two columns to minmax data frame to record probability of switching
minmax[c("maxSwitchProb", "minSwitchProb")] <- NA

for (p in unique(curdat$Pair)) { # p = pair
  
  # swMax = sum of switches for maxAgent / no. of trials in which maxAgent could switch (i.e., acted first)
  # sanity check: length(curdat[curdat$Pair==p & curdat$mima_dec1=="max","switchMax"])==
  #               length(curdat[curdat$Pair==p & curdat$switchMax!=0,"switchMax"])
  swMax=sum(curdat[curdat$Pair==p & curdat$switchMax==1,"switchMax"]) /
        length(curdat[curdat$Pair==p & curdat$switchMax!=0,"switchMax"])
  swMin=sum(curdat[curdat$Pair==p & curdat$switchMin==1,"switchMin"]) /
    length(curdat[curdat$Pair==p & curdat$switchMin!=0,"switchMin"])
  
  minmax[minmax$Pair==p,"maxSwitchProb"]=swMax
  minmax[minmax$Pair==p,"minSwitchProb"]=swMin
}
```

```{r saveExcel, echo=FALSE, warning=FALSE, error=FALSE, message=FALSE}
################################################################################
# SAVE CURDAT INTO EXCEL FILE HERE - make sure that all vars are added before
if (save_data_final) {
  curpath = dirname(dirname(DataDir)) # save in Experiment/Data
  write_xlsx(curdat, path = paste0(curpath,"/jmdData_allPairs.xlsx"),
             col_names = TRUE, format_headers = TRUE)
  # also save info on lost trials etc.
  dataInfo = jmdData_info(curdat)
  write_xlsx(dataInfo, path = paste0(curpath,"/jmdData_Info.xlsx"),
             col_names = TRUE, format_headers = TRUE)
}
################################################################################
```

```{r plotParams, echo=FALSE, warning=FALSE, error=FALSE, message=FALSE}
# Configure plot parameters
# -------------------------
pd            = position_dodge(0.001)
acc_scale     = list("lim"=c(0,1),"breaks"=seq(0,1, by=0.2))
acc_scale2    = list("lim"=c(0,0.85),"breaks"=seq(0,0.85, by=0.1)) # for mean values up to ~0.8
target_scale  = list("breaks"=sort(unique(curdat$targetContrast)),"labels"=sort(unique(curdat$targetContrast)))
conf_scale    = list("lim"=c(1,6),"breaks"=seq(1,6, by=1)) #"labels"=c(1,2,3,4,5,6))
conf_scale2   = list("lim"=c(1,4.5),"breaks"=seq(1,4.5, by=1)) # for mean values up to ~4
conf_scale4   = list("lim"=c(1,4),"breaks"=seq(1,4, by=1)) # for mean values up to ~4
time_scale    = list("lim"=c(0,2),"breaks"=seq(0,2, by=0.25))
mov_scale     = list("lim"=c(0.5,1.75),"breaks"=seq(0.5,1.75, by=0.25))
switch_colors = c("lightcoral", "lightgreen")
bar_colors    = c("gray88", "gray44", "lightcoral", "lightgreen")
con_colors    = c("#D1E5F0", "#92C5DE", "#4393C3", "#2166AC")
con_scale     = list("lim"=c(0,125),"breaks"=seq(0,125, by=25))
col_12C       = RColorBrewer::brewer.pal(5, "Paired")[3:5] # light green,dark green,light red
col_mimaC     = RColorBrewer::brewer.pal(5, "Paired")[c(2,1,5)] # light green,dark green,light red
```

<br>
### Initial checks on the data
<br>
#### Overall distribution of confidence (high/low), (dis)agreement, and change of mind ("switch")

```{r proportionHighLowConfidence, echo=FALSE, warning=FALSE, error=FALSE, message=TRUE}
# Check PROPORTIONS: high/low confidence, agreement/disagreement, switch/no switch
# --------------------------------------------------------------------------------
# count trials separately for each agent B /Y for low and high confidence
lo_conf_trialcount_B = dim(curdat[(curdat$B_conf>=1 & curdat$B_conf<=3),])[1]
lo_conf_trialcount_Y = dim(curdat[(curdat$Y_conf>=1 & curdat$Y_conf<=3),])[1]
lo_conf_trialcount   = lo_conf_trialcount_B+lo_conf_trialcount_Y
hi_conf_trialcount_B = dim(curdat[(curdat$B_conf>3),])[1]
hi_conf_trialcount_Y = dim(curdat[(curdat$Y_conf>3),])[1]
hi_conf_trialcount   = hi_conf_trialcount_B+hi_conf_trialcount_Y
# divide by total trial number*2 (because each agent took 1 ind. dec. per trial)
lo_conf_perc         = round(100*(lo_conf_trialcount/(2*(dim(curdat)[1]))))
hi_conf_perc         = round(100*(hi_conf_trialcount/(2*(dim(curdat)[1]))))
sprintf("Low confidence decisions (1-3): %d %s", lo_conf_perc, "%")
sprintf("High confidence decisions (4-6): %d %s", hi_conf_perc, "%")

# Percentage of (dis)agreement trials relative to all trials
perc_dt = round(100*(dim(dt)[1]/dim(curdat)[1])) #40% in exp #39% in pilot
perc_at = round(100*(dim(at)[1]/dim(curdat)[1])) #60% in exp #61% in pilot
sprintf("Disagreement trials: %d %s", perc_dt, "%")
sprintf("Agreement trials: %d %s", perc_at, "%")

# Percentage of switch/noswitch in case of disagreement (and for all trials)
dt_switch         = dt[dt$switch==1,]
dt_noswitch       = dt[dt$switch==-1,]
perc_dt_switch    = round(100*(dim(dt_switch)[1]/dim(dt)[1]))     #54% #64% in pilot
perc_dt_noswitch  = round(100*(dim(dt_noswitch)[1]/dim(dt)[1]))   #46% #36% in pilot
perc_all_switch   = round(100*(dim(dt_switch)[1]/dim(curdat)[1])) #21% #25% in pilot
perc_all_noswitch = round(100*(dim(dt_noswitch)[1]/dim(curdat)[1])+100*(dim(at)[1]/dim(curdat)[1])) #79% #75% in pilot
sprintf("Switch as proportion of disagreement trials: %d %s", perc_dt_switch, "%")
sprintf("No switch as proportion of disagreement trials: %d %s", perc_dt_noswitch, "%")
sprintf("Switch/no switch as proportion of all trials: %d %s %d %s", perc_all_switch, "% /", perc_all_noswitch, "%")
# Check if there is switching in case of agreement (1st = 2nd decision)
at_switch = at[at$switch==1,] # should be empty (no switch if agreement)
if (nrow(at_switch) == 0) {
  print("ALL GOOD: No switches if co-actors agree!")
} else {
  print("WHAAAT? Switches even if agreement?")
}
```

<br>
<br>
### Distribution of Confidence ratings

```{r confDistributionPerDecisionPREP, echo=FALSE, warning=FALSE, error=FALSE, message=FALSE}
# 1. Confidence distribution - HISTOGRAMS
all_conf = curdat[,c("Pair","confidence1","confidence2","Coll_conf","targetContrast")]
names(all_conf)[names(all_conf)=='confidence1'] <- 'Confidence 1st decision'
names(all_conf)[names(all_conf)=='confidence2'] <- 'Confidence 2nd decision'
names(all_conf)[names(all_conf)=='Coll_conf']   <- 'Confidence collective decision'
all_conf$targetContrast = as.factor(all_conf$targetContrast)
count_scale_conftar     = list("lim"=c(0,200),"breaks"=seq(0,200, by=25))
count_scale_conf        = list("lim"=c(0,700),"breaks"=seq(0,700, by=50))
```

<br>
#### Frequency for each confidence level (and target contrast)

```{r confDistributionPerDecision, echo=FALSE, fig.show="hold", out.width="50%"}
for(confy in (seq(2,ncol(all_conf)-1))) { # take columns 2-4 in all_conf
  var_conf = all_conf[,confy] # confy=confidence1,confidence2,Coll_Conf
  # plot confidence count split by target contrast
  print(ggplot(all_conf, aes(x=var_conf, fill=targetContrast)) +
          scale_fill_manual(values=con_colors)+ 
          stat_count(geom = "bar", position="dodge2") +
          scale_y_continuous(limits = count_scale_conftar$lim, breaks = count_scale_conftar$breaks) +
          scale_x_continuous(breaks = conf_scale$breaks, labels = conf_scale$breaks) +
          ggtitle(colnames(all_conf)[confy]) +
          ylab("Count") + xlab("Confidence level") + theme_custom())
  # save the plot
  if (save_plots) {ggsave(file=sprintf(paste0("%sConfidenceHist_",as.character(confy-1),"_target.png"),PlotDir), 
                          dpi = 300, units=c("cm"), height =20, width = 20)}
  
  # plot confidence count
  print(ggplot(all_conf, aes(x=var_conf)) +
          stat_count(geom = "bar", position="dodge2") +
          scale_y_continuous(limits = c(0,600), breaks = seq(0,600, by=50)) +
          #scale_y_continuous(limits = count_scale_conf$lim, breaks = count_scale_conf$breaks) +
          scale_x_continuous(breaks = conf_scale$breaks, labels = conf_scale$breaks) +
          ggtitle(colnames(all_conf)[confy]) +
          ylab("Count") + xlab("Confidence level") + theme_custom())
  # save the plot
  if (save_plots) {ggsave(file=sprintf(paste0("%sConfidenceHist_",as.character(confy-1),".png"),PlotDir), 
                          dpi = 300, units=c("cm"), height =20, width = 20)}
}
```

<br>
#### Frequency for each confidence level per pair and agent (Blue/Yellow)

```{r confDistributionPerPair, echo=FALSE, fig.show="hold", out.width="25%"}
check_confDistribution(curdat)
```

<br>
<br>
### Average accuracy per decision

```{r averageAccuracyPREP, echo=FALSE, warning=FALSE, error=FALSE, message=FALSE}
# 2. Accuracy by confidence/target contrast

# preparatory steps
# plot titles
dec_names = c("1st decision","2nd decision","Collective decision") 
# column names
p = "Pair"; ag = "agree"; sw = "switch"; Bconf = "B_conf"; Yconf = "Y_conf"
agent1 = "AgentTakingFirstDecision"; agent2 = "AgentTakingSecondDecision"

# 2.0 Average accuracy per decision (1st, 2nd, coll)
# --------------------------------------------------
threeCol     = col_12C
data_all_acc = curdat[,c("Pair","accuracy1","accuracy2","Coll_acc")]
# transform into long format
data_all_acc_long = melt(data_all_acc, id="Pair")
# SUMMARY STATS per PAIR
data_all_acc_sub  = summarySE(data_all_acc_long,measurevar="value",groupvars=c("Pair","variable"))
# SUMMARY STATS across PAIRS
data_all_acc_sum  = summarySE(data_all_acc_sub,measurevar="value",groupvars="variable")
```

```{r averageAccuracy, echo=FALSE, warning=FALSE, error=FALSE, message=FALSE}
ggplot(data_all_acc_sum,aes(x=variable,y = value)) +
  geom_point(data=data_all_acc_sum, aes(y = value, color = threeCol),alpha=0.9, size=3) + 
  scale_color_manual(values = threeCol) +
  geom_errorbar(aes(x=variable, ymin=value-se, ymax=value+se, color = threeCol,), width=0.2, alpha=0.9, size=1) +
  geom_hline(yintercept=0.5, linetype='dashed', col = 'limegreen', size=1.4, alpha=0.6) +
  scale_x_discrete(labels = c("1st","2nd","Collective")) +
  scale_y_continuous(limits = c(0.5,1), breaks = seq(0.5,1, by=0.1)) +
  ggtitle("Accuracy by decision") +
  ylab("Accuracy") + xlab("Decision") + theme_custom()
if (save_plots) {ggsave(file=sprintf("%sAccPerDec.png",PlotDir), 
                        dpi = 300, units=c("cm"), height =20, width = 20)}
```

<br>
<br>
### Average accuracy as a function of confidence (and agreement)

```{r ConfAccRelationship1, echo=FALSE, fig.show="hold", out.width="50%", warning=FALSE, error=FALSE, message=FALSE}
# 2a. Accuracy as function of confidence
# --------------------------------------
# Note: this is a big for-loop going through all 3 decisions and ag/disag(switch/noswitch)
for(confVar in 1:3) {
  
  if (confVar==1){
    conf="confidence1"; acc="accuracy1"
  }else if (confVar==2) {
    conf="confidence2"; acc="accuracy2"
  }else if (confVar==3) {
    conf="Coll_conf";   acc="Coll_acc"
  }
  
  all_conf_acc        = curdat[,c(p,acc,conf)]
  all_conf_acc_sub    = summarySE(all_conf_acc,measurevar=acc,groupvars=c(p,conf))
  all_conf_acc_sum    = summarySE(all_conf_acc_sub,measurevar=acc,groupvars=c(conf))
 
  print(ggplot(all_conf_acc_sum) +
          geom_bar( aes(x=get(conf), y=get(acc)), stat="identity", fill="grey", alpha=0.7) +
          geom_errorbar( aes(x=get(conf), ymin=get(acc)-se, ymax=get(acc)+se), width=0.2, colour="black", alpha=0.9, size=1)+
          geom_hline(yintercept=0.5, linetype='dashed', col = 'limegreen', size=1.4, alpha=0.6) +
          scale_y_continuous(limits = acc_scale$lim, breaks = acc_scale$breaks) +
          scale_x_continuous(breaks = conf_scale$breaks, labels = conf_scale$breaks) +
          ggtitle(dec_names[confVar]) +
          ylab("Accuracy") + xlab("Confidence") + theme_custom())
  if (save_plots) {ggsave(file=sprintf(paste0("%sConfidenceAcc_",as.character(confVar),".png"),PlotDir), 
                          dpi = 300, units=c("cm"), height =20, width = 20)}
  
  # add agreement factor to the original bar plots
  data_ag     = curdat[,c(p,acc,conf,ag)]
  data_sub_ag = summarySE(data_ag,measurevar=acc,groupvars=c(p,conf,ag))
  data_sum_ag = summarySE(data_sub_ag,measurevar=acc,groupvars=c(conf,ag))
  # factorize and rename
  data_sum_ag$agree = as.factor(data_sum_ag$agree)
  levels(data_sum_ag$agree)= c("disagree","agree")
  names(data_sum_ag)[names(data_sum_ag)=="agree"]="Agreement"
  
  print(ggplot(data_sum_ag, aes(x = get(conf), y = get(acc), colour = Agreement)) +
          geom_point(position = position_dodge(width = 0.2), alpha=0.9, size=4)+
          geom_errorbar(aes(x=get(conf), ymin=get(acc)-se, ymax=get(acc)+se, colour = Agreement),
                        position = position_dodge(width = 0.2), width=0.2, alpha=0.9, size=1)+
          geom_hline(yintercept=0.5, linetype='dashed', col = 'limegreen', size=1.4, alpha=0.6) +
          scale_y_continuous(limits = acc_scale$lim, breaks = acc_scale$breaks) +
          scale_x_continuous(breaks = conf_scale$breaks, labels = conf_scale$breaks) +
          ggtitle(dec_names[confVar]) +
          ylab("Accuracy") + xlab("Confidence") + theme_custom())
  if (save_plots) {ggsave(file=sprintf(paste0("%sConfidenceAcc_",as.character(confVar),"_agdag.png"),PlotDir), 
                          dpi = 300, units=c("cm"), height =20, width = 20)}
 
  # now create scatter plots, one dot per agent per confidence level
  # if(confVar==1 | confVar==3){
  #   data_agent = curdat[,c(p,agent1,acc,conf,ag,sw)]
  #   names(data_agent)[names(data_agent)==agent1] = "agent"
  #   data_sum_agent = summarySE(data_agent,measurevar=acc,groupvars=c(p,"agent",conf))
  # }else if (confVar==2){
  #   data_agent = curdat[,c(p,agent2,acc,conf,ag,sw)]
  #   names(data_agent)[names(data_agent)==agent2] = "agent"
  #   data_sum_agent = summarySE(data_agent,measurevar=acc,groupvars=c(p,"agent",conf))
  # }
  # 
  # print(ggplot(data_sum_agent, aes(x=get(acc), y=get(conf), color=interaction(as.factor(agent),as.factor(get(p))))) + 
  #         geom_point(shape=1) + scale_colour_discrete() + 
  #         scale_x_continuous(limits = c(0.2,1), breaks = acc_scale$breaks) +
  #         scale_y_continuous(breaks = conf_scale$breaks, labels = conf_scale$breaks) +
  #         ggtitle(dec_names[confVar]) +
  #         xlab("Accuracy") + ylab("Confidence") + theme_custom() +
  #         geom_smooth(method=lm,se=FALSE, size=0.5))
  # if (save_plots) {ggsave(file=sprintf(paste0("%sConfAcc_",as.character(confVar),"_agents.png"),PlotDir), 
  #                         dpi = 300, units=c("cm"), height =20, width = 20)}
  
  
  # create separate plots for agreement and disagreement (+switch) trials
  # for(agVar in 1:2) {
  #   
  #   # agreement
  #   if (agVar==1)    {  
  #     data_sum_p_ag = summarySE(data_agent,measurevar=acc,groupvars=c(p,"agent",conf,ag));
  #     data_sum_p_ag = data_sum_p_ag[data_sum_p_ag$agree==1,]; alab="agree"
  #     print(ggplot(data_sum_p_ag, aes(x=get(acc), y=get(conf), color=interaction(as.factor(agent),as.factor(get(p))))) + 
  #             geom_point(shape=1) + scale_colour_discrete() + 
  #             scale_x_continuous(limits = c(0.2,1), breaks = acc_scale$breaks) +
  #             scale_y_continuous(breaks = conf_scale$breaks, labels = conf_scale$breaks) +
  #             ggtitle(paste(dec_names[confVar],alab,sep=" ")) +
  #             xlab("Accuracy") + ylab("Confidence") + theme_custom() +
  #             geom_smooth(method=lm,se=FALSE, size=0.5))
  #     if (save_plots) {ggsave(file=sprintf(paste0("%sConfAcc_",as.character(confVar),"_agents_agree.png"),PlotDir), 
  #                             dpi = 300, units=c("cm"), height =20, width = 20)}
  #   }
  #   # disagreement
  #   else if (agVar==2) {
  #     # decisions 1 and 2
  #     if (confVar==1 || confVar==2) {
  #       data_sum_p_ag = summarySE(data_agent,measurevar=acc,groupvars=c(p,"agent",conf,ag));
  #       data_sum_p_ag = data_sum_p_ag[data_sum_p_ag$agree==-1,]; alab="disagree"
  #       print(ggplot(data_sum_p_ag, aes(x=get(acc), y=get(conf), color=interaction(as.factor(agent),as.factor(get(p))))) +
  #               geom_point(shape=1) + scale_colour_discrete() +
  #               scale_x_continuous(limits = c(0.2,1), breaks = acc_scale$breaks) +
  #               scale_y_continuous(breaks = conf_scale$breaks, labels = conf_scale$breaks) +
  #               ggtitle(paste(dec_names[confVar],alab,sep=" ")) +
  #               xlab("Accuracy") + ylab("Confidence") + theme_custom() +
  #               geom_smooth(method=lm,se=FALSE, size=0.5))
  #       if (save_plots) {ggsave(file=sprintf(paste0("%sConfAcc_",as.character(confVar),"_agents_disagree.png"),PlotDir), 
  #                               dpi = 300, units=c("cm"), height =20, width = 20)}
  #     }
  #     # collective decision: split into switch and no switch
  #     else if (confVar==3) {
  #       for(swVar in 1:2) {
  #         data_sum_p_ag = summarySE(data_agent,measurevar=acc,groupvars=c(p,"agent",conf,ag,sw));
  #         if (swVar==1){
  #           data_sum_p_ag=data_sum_p_ag[data_sum_p_ag$agree==-1 & data_sum_p_ag$switch==1,]; alab="disagree&change"
  #         }else if (swVar==2){
  #           data_sum_p_ag=data_sum_p_ag[data_sum_p_ag$agree==-1 & data_sum_p_ag$switch==-1,]; alab="disagree&nochange"
  #         }
  #         
  #         print(ggplot(data_sum_p_ag, aes(x=get(acc), y=get(conf), color=interaction(as.factor(agent),as.factor(get(p))))) + 
  #                 geom_point(shape=1) + scale_colour_discrete() + 
  #                 scale_x_continuous(limits = c(0.2,1), breaks = acc_scale$breaks) +
  #                 scale_y_continuous(breaks = conf_scale$breaks, labels = conf_scale$breaks) +
  #                 ggtitle(paste(dec_names[confVar],alab,sep=" ")) +
  #                 xlab("Accuracy") + ylab("Confidence") + theme_custom() +
  #                 geom_smooth(method=lm,se=FALSE, size=0.5))
  #         if (save_plots) {ggsave(file=sprintf(paste0("%sConfAcc_",as.character(confVar),"_agents_disagree_",as.character(swVar),".png"),PlotDir), 
  #                                 dpi = 300, units=c("cm"), height =20, width = 20)}
  #       }
  #     }
  #   }
  # }
}
```

<br>
<br>
### Explore confidence-accuracy relationship further:

```{r ConfAccRelationship2, echo=FALSE, fig.show="hold", out.width="33%", warning=FALSE}
#####################################################
#### FOCUS ON CONFIDENCE - ACCURACY RELATIONSHIP ####
# 2b. Conf/Acc as function of difficulty (target contrast)
# --------------------------------------------------------
# First plot all three decisions into the same plot

# Which decision types to plot?
dec2plot      = 2; # 1=1st/2nd/coll, 2=max,min,coll
# Sub-select? if so: agreement or disagreement trials?
subselect     = 0; # 1=yes,   0=no
sub_agreement = 1; # 1=agree, 0=disagree 

# Do a for-loop for (selectSubset in 1:3)
# if (selectSubset==3) { # no subset, all trials
#   subselect = 0; 
# } else if (selectSubset==1) { # only agreement
#   subselect = 1; sub_agreement = 1; 
# } else if (selectSubset==2) { # only disagreement
#   subselect = 1; sub_agreement = 0; 
# } 

# Prepare data set accordingly
if (subselect) {
  if (sub_agreement) {
    at        = curdat[curdat$agree==1,]
    data_coac = at[,c("Pair","targetContrast",
                      "B_conf","B_acc","Y_conf","Y_acc","maxConf","maxAcc","minConf","minAcc",
                      "confidence1","confidence2","Coll_conf","accuracy1", "accuracy2", "Coll_acc")]
    agree_lab = '_agree'; agree_title = '- agreement'; 
  } else {
    dt        = curdat[curdat$agree==-1,]
    data_coac = dt[,c("Pair","targetContrast",
                      "B_conf","B_acc","Y_conf","Y_acc","maxConf","maxAcc","minConf","minAcc",
                      "confidence1","confidence2","Coll_conf","accuracy1", "accuracy2", "Coll_acc")]
    agree_lab = '_disagree'; agree_title = '- disagreement';
  }
} else {
  data_coac = curdat[,c("Pair","targetContrast",
                        "B_conf","B_acc","Y_conf","Y_acc","maxConf","maxAcc","minConf","minAcc",
                        "confidence1","confidence2","Coll_conf","accuracy1", "accuracy2", "Coll_acc")]
  agree_lab = ''; agree_title = '';
}

# transform data_coac into long format
data_coac_long = melt(data_coac, id=c("Pair", "targetContrast"))
# compute SUMMARY statistics, PER PAIR
data_coac_sum  = summarySE(data_coac_long,measurevar="value",groupvars=c("Pair","targetContrast","variable"))

# create separate data subsets for confidence and accuracy
if (dec2plot==1) {
  data_co = data_coac_sum[data_coac_sum$variable=="confidence1" | data_coac_sum$variable=="confidence2" | data_coac_sum$variable=="Coll_conf",]
  data_ac = data_coac_sum[data_coac_sum$variable=="accuracy1" | data_coac_sum$variable=="accuracy2" | data_coac_sum$variable=="Coll_acc",]
  threeCol= col_12C; dec_lab = '_12'; 
} else {
  data_co = data_coac_sum[data_coac_sum$variable=="maxConf" | data_coac_sum$variable=="minConf" | data_coac_sum$variable=="Coll_conf",]
  data_ac = data_coac_sum[data_coac_sum$variable=="maxAcc" | data_coac_sum$variable=="minAcc" | data_coac_sum$variable=="Coll_acc",]
  threeCol= col_mimaC; dec_lab = '_mima';
}

# filter subsets to avoid having value = 0 in denominator of caR (happens if only 1 value for accuracy)
data_ac_filt = data_ac[data_ac$value>0,]
data_co_filt = data_co[data_ac$value>0,]
# create C-A ratio data set, based on data_co and data_ac
data_caR     = data_co_filt
data_caR$caR = data_co_filt$value/data_ac_filt$value # compute ratio per row

# change variable names in caR
data_caR$variable=factor(data_caR$variable)
if (dec2plot==1) {
  levels(data_caR$variable)=c("decision1","decision2","decisionColl")
} else {
  levels(data_caR$variable)=c("decisionMax","decisionMin","decisionColl")
}

# compute SUMMARY statistics, ACROSS PAIRS
data_caR_sum = summarySE(data_caR,measurevar="caR",groupvars=c("targetContrast","variable")) 
data_co_sum  = summarySE(data_co_filt,measurevar="value",groupvars=c("targetContrast","variable")) 
data_ac_sum  = summarySE(data_ac_filt,measurevar="value",groupvars=c("targetContrast","variable")) 

# 1. plot CONFIDENCE by target contrast for all 3 decision types (within one plot)
ggplot(data_co_sum, aes(x = targetContrast, y = value)) + 
  geom_line(data=data_co_sum, aes(y = value, color = variable), lwd = .7) + 
  geom_point(data=data_co_sum, aes(y = value, color = variable)) +
  scale_color_manual(values = threeCol) + 
  geom_ribbon(data=data_co_sum, aes(ymin = value-se, ymax = value+se, fill = variable),
              alpha = .3, color = "transparent") +
  scale_fill_manual(values = threeCol) + 
  xlim(0.115, 0.250) + ylim(2.0,4.75) +
  ggtitle(paste("Individual and collective confidence",agree_title)) +
  labs(x = "Target contrast", y = "Confidence") + theme_custom()
if (save_plots) {ggsave(file=sprintf(paste0("%sallDec_ConfByContrast",dec_lab,agree_lab,".png"),PlotDir), 
                        dpi = 300, units=c("cm"), height =20, width = 20)}

# 2. plot ACCURACY by target contrast for all 3 decision types (within one plot)
ggplot(data_ac_sum, aes(x = targetContrast, y = value)) +
  geom_line(data=data_ac_sum, aes(y = value, color = variable), lwd = .7) + 
  geom_point(data=data_ac_sum, aes(y = value, color = variable)) + 
  scale_color_manual(values = threeCol) +
  geom_ribbon(data=data_ac_sum, aes(ymin = value-se, ymax = value+se, fill = variable),
              alpha = .3, color = "transparent") +
  scale_fill_manual(values = threeCol) +
  xlim(0.115, 0.250) + ylim(0.3,1) +
  ggtitle(paste("Individual and collective accuracy",agree_title)) +
  labs(x = "Target contrast", y = "Accuracy") + theme_custom()
if (save_plots) {ggsave(file=sprintf(paste0("%sallDec_AccByContrast",dec_lab,agree_lab,".png"),PlotDir), 
                        dpi = 300, units=c("cm"), height =20, width = 20)}

# 3. plot C-A RATIO by target contrast for all 3 decision types (within one plot)
ggplot(data_caR_sum, aes(x = targetContrast, y = caR)) +
  geom_line(data=data_caR_sum, aes(y = caR, color = variable), lwd = .7) + 
  geom_point(data=data_caR_sum, aes(y = caR, color = variable)) +
  scale_color_manual(values = threeCol) +
  geom_ribbon(data=data_caR_sum, aes(ymin = caR-se, ymax = caR+se, fill = variable),
              alpha = .3, color = "transparent")+
  scale_fill_manual(values = threeCol) +
  xlim(0.115, 0.250) + ylim(3,9.5) +
  ggtitle(paste("Individual and collective CA-ratio",agree_title)) +
  labs(x = "Target contrast", y = "Confidence/Accuracy") + theme_custom()
if (save_plots) {ggsave(file=sprintf(paste0("%sallDec_ConfRContrast",dec_lab,agree_lab,".png"),PlotDir), 
                        dpi = 300, units=c("cm"), height =20, width = 20)}


```

<br>
<br>
### Compare confidence between better(max) and worse(min) agent

```{r minmaxComparison, echo=FALSE, fig.show="hold", out.width="30%", warning=FALSE, error=FALSE, message=FALSE}
###############
# RUN MIN-MAX COMPARISON with function compareMinMax
# IMPORTANT: the function uses data_co_sum from above - before running the following,
# make sure that subselect=0 and dec2plot=2

# Decide if you want to include collective decision (as var) and targetContrast (as factor)
wCollconf = 0 # 0=without collective, 1=with collective
wtarget   = 1 # 0=average across targets, 1=target as factor
# now run function
compareMinMax(wCollconf,wtarget,data_co_sum)
###############
```
